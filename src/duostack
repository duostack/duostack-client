#!/usr/bin/env ruby

$client = File.basename(__FILE__)

require 'cgi'


# parse app name out of arguments
app = if app_index = ARGV.index('--app')
  app_name_source = :flag
  # slice out app args so we don't re-use them later, returning second element.
  # will be nil if no app name is passed after --app; that's okay.
  ARGV.slice!(app_index, 2)[1]
else
  app_name_source = :git_remote
  # fall back to parsing out of duostack git remote
  `git remote -v 2>&1 | grep -m1 git@duostack.net | grep ".git" | cut -f 2 -d: | cut -f 1 -d.`.chomp
end

# pull flags out of arguments (has to happen after app flag is extracted)
flags = ARGV.select { |arg| arg[0..1] == '--' }
ARGV.delete_if { |arg| flags.include?(arg) }

# parse out confirmedness
$confirmed = app_name_source == :flag && flags.delete('--confirm')
def require_confirmation
  unless $confirmed
    warn "#{$client}: command requires confirmation, run again with '--confirm --app <appname>'"
    exit false
  end
end

# parse out CRUD commands (two-part commands)
command_noun, command_verb, command_argument = [nil]*3
['env'].each do |command_candidate|
  
  # look for any instances of CRUD commands
  if command_index = ARGV.index(command_candidate)
    command_noun = command_candidate
    command_verb = if %w(add remove rm list ls clear).include?(ARGV[command_index+1])
      ARGV[command_index+1]
    else
      'list' # default command
    end
    command_argument = if %w(add remove rm).include?(command_verb)
      # takes all following arguments. recompose strings because ruby strips out quotation marks in the args.
      ARGV[(command_index+2)..-1].collect do |arg|
        if arg.include?('=')
          result = arg.split('=',2)
          %Q(#{result[0]}="#{result[1].gsub('"', '\"')}")
        else
          arg
        end
      end.join(' ')
    end
    ARGV.slice!(command_index..-1) # clear args we've handled out of array
    break
  end
end


if ARGV.length > 0 && ARGV[0] == "version"
  puts "0.0.9"
  exit
end

if `file ~/.ssh/id_rsa.pub`[/text|key/]
  idfile = '~/.ssh/id_rsa.pub'
elsif `file ~/.ssh/id_dsa.pub`[/text|key/]
  idfile = '~/.ssh/id_dsa.pub'
elsif `file ~/.ssh/identity.pub`[/text|key/]
  idfile = '~/.ssh/identity.pub'
else
  warn "#{$client}: generate an SSH key before running this client"
  exit false
end

$api_host = "https://duostack.duostack.net"
if !`curl -V`[/SSL/]
  $api_host = "http://duostack.duostack.net"
  warn "#{$client}: insecure plaintext mode because curl SSL support is missing"
end
$api_host = "http://localhost:3000" if ENV['DSLOCAL']
puts "Internal development mode" if ENV['DSLOCAL']

$credentials=`cat ~/.duostack 2>/dev/null`.chomp
if $credentials.empty? || $credentials[/redirected/]
  puts "First-time Duostack client setup"
  print "Email Address: "
  input_username = $stdin.gets.chomp
  ssh_key = `cat #{idfile}`.chomp
  puts `bash -c 'read -sp "Password: " passwd; echo $passwd > ~/.duostack2'`
  input_password = CGI::escape(`cat ~/.duostack2`.chomp)
  `rm -f ~/.duostack2`
  `curl -m 5 "#{$api_host}/api/get_token?api_username=#{CGI::escape(input_username)}&api_password=#{input_password}&ssh_key=#{CGI::escape(ssh_key)}" -o ~/.duostack -s 2>&1 >/dev/null`
  $credentials=`cat ~/.duostack 2>/dev/null`.chomp
  if $credentials.empty? || $credentials[/redirected/] || $credentials.length != 32
    puts "Authentication error, please try again"
    `rm -f ~/.duostack`
    exit false
  end
  `echo 'api_username=#{CGI::escape(input_username)}&api_token=#{$credentials}' > ~/.duostack`
  $credentials=`cat ~/.duostack 2>/dev/null`.chomp
  puts "Completed initial setup... waiting for sync..."
  # Do a sync check here in the future, 4 secs is safe for now
  sleep 4
  puts ""
end

def api_get(url)
  debug = `echo curl -m 30 -w '\n%{http_code}' "#{$api_host}/#{url}&#{$credentials}" -sf`
  result = `curl -m 30 -w '\n%{http_code}' "#{$api_host}/#{url}&#{$credentials}" -sf`
  debug += result
  puts debug if ENV['DSDEBUG']
  
  result = result.split("\n")
  if result.last != '200'
    return "API Error"
  else
    return result[0..-2].join("\n")
  end
end

if (!command_noun && ARGV.length == 0) || ARGV[0] == "help"
  puts <<-EOF
Usage: #{$client} <command> [--app <appname>]

General Commands:
  create <app name>     Initialize a Git repository as a Duostack app
  list                  Show all associated Duostack apps
  version               Print version of this Duostack client

App Commands:
  logs                  Retrieve server logs
  restart               Restart your instances
  ps                    List your instances and their statuses
  destroy               Destroy Duostack app and associated data

App Commands - Ruby:
  console               Connect to IRB/Rails console
  rake <command>        Run a rake command

EOF
  exit
end

if ARGV[0] == "list"
  result = api_get("api/list_apps?1")
  unless result == 'API Error'
    puts result
    exit
  else
    warn "#{$client}: no apps found"
    exit false
  end
end

if ARGV[0] == "create"
  if ARGV.length < 2
    warn "#{$client}: try '#{$client} create <app name>'"
    exit false
  end
  if `git status 2>&1`[/Not a git/]
    warn "#{$client}: initialize Git repository before using create"
    exit false
  end
  if !app.empty?
    warn "#{$client}: this repository is already initialized for Duostack"
    exit false
  end
  # check if remote duostack already exists in the future
  if api_get("api/create_app?app_name=#{CGI::escape(ARGV[1].downcase)}")[/SUCCESS/]
    `git remote add duostack git@duostack.net:#{CGI::escape(ARGV[1].downcase)}.git`
    puts "Duostack initialized. To push: git push duostack master"
    exit
  else
    puts "This app name is unavailable. Please try another."
    exit false
  end
end




# anything beyond this point is an app command, so require the app to be specified
if app.nil? or app.empty?
  warn "#{$client}: run this command from a Duostack app folder or pass an app name with the --app argument"
  exit false  
end

if command_noun == 'env'
  
  case command_verb
  when 'list', 'ls'
    truncate = !flags.delete('--long')
    result = api_get("api/list_envs?app_name=#{app}&truncate=#{truncate}")
    unless result == 'API Error'
      puts result
      exit
    else
      puts "Unable to list environment variables"
      exit false
    end
    
  when 'add'
    result = api_get("api/add_env?app_name=#{app}&input=#{CGI::escape(command_argument)}")
    unless result == 'API Error'
      puts result
      exit
    else
      puts "Unable to add environment variable(s)"
      exit false
    end
    
  when 'remove', 'rm'
    result = api_get("api/remove_env?app_name=#{app}&name=#{CGI::escape(command_argument)}")
    if result[/SUCCESS/]
      puts "Environment variable(s) removed"
      exit
    else
      puts "Unable to remove environment variable(s)"
      exit false
    end
    
  when 'clear'
    require_confirmation
    
    result = api_get("api/clear_envs?app_name=#{app}")
    if result[/SUCCESS/]
      puts "Environment variables cleared"
      exit
    else
      puts "Unable to clear environment variables"
      exit false
    end
  else
    exit false # this shouldn't happen
  end
end


if ARGV[0] == "option"
  
  name, value = ARGV[1..2] # value will be nil if there is no ARGV[2]
  
  if name
    if value
      result = api_get("api/option_set?app_name=#{app}&name=#{name}&val=#{value}")
      unless result == 'API Error'
        puts result
        exit
      else
        puts "Unable to set option"
        exit false
      end
      
    else
      # no value given, get option list
      result = api_get("api/option_get?app_name=#{app}&name=#{name}")
      unless result == 'API Error'
        puts result
        exit
      else
        puts "Unable to get option"
        exit false
      end
    end
    
  else
    warn "#{$client}: try '#{$client} define <option> <value>'"
    exit false
  end
  
end


if ARGV[0] == "console"
  exec(".duostack-console-expect #{app}")
  exit
end

if ARGV[0] == "rake"
  if ARGV.length < 2
    warn "#{$client}: try '#{$client} rake <command..>'"
    exit false
  end
  # Need this to go longer
  result = `curl -m 60 "#{$api_host}/api/run_rake?app_name=#{app}&command=#{CGI::escape(ARGV[1,999].join(' '))}&#{$credentials}" -s`
  if result[/\n/]
    puts result
    exit
  else
    puts "Unable to run rake task"
    exit false
  end
end

if ARGV[0] == "restart"
  get_log = api_get("api/restart?app_name=#{app}")
  if get_log[/SUCCESS/]
    puts "App restarted"
    exit
  else
    puts "Unable to restart app"
    exit false
  end
end

if ARGV[0] == "logs"
  get_log = api_get("api/get_logs?app_name=#{app}")
  if get_log[/\.log/]
    puts get_log
    exit
  else
    warn "#{$client}: no logs found"
    exit false
  end
end

if ARGV[0] == "ps"
  result = api_get("api/get_instances?app_name=#{app}")
  if result[/Instance ID|Status/]
    puts result
    exit
  else
    warn "#{$client}: unable to get instances"
    exit false
  end
end

if ARGV[0] == "destroy"
  
  require_confirmation
  
  remote = `git remote show duostack 2>/dev/null`     # pull out remote name before we destroy
  result = api_get("api/delete_app?app_name=#{app}")  # destroy
  
  if result[/SUCCESS/]
    # attempt to remove duostack git remote
    # only if "duostack" remote actually references this app's remote
    if !remote.empty? and remote.scan("git@duostack.net:#{app}.git").length > 0
      `git remote rm duostack 2>/dev/null`
    end
    
    puts "App destroyed"
    exit
  else
    puts "Unable to destroy app"
    exit false
  end

end

puts "#{$client}: for usage, run '#{$client}' without arguments"
exit false
