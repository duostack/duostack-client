#!/usr/bin/env ruby
require 'cgi'

module Duostack
  class Client
    
    VERSION = '0.1.0'
    USER_AGENT = "duostack-#{VERSION}"
    
    FLAGS = ['confirm', 'long']      # app is one too but gets special handling
    
    COMMANDS = {
      :default => 'help',            # command used when no other command is given
      :general => %w(version help),  # general commands, can always be run
      :user    => %w(create list),   # commands requiring a credentials (first-time setup)
      :app     => [                  # commands requiring an app to be specified (either by git inference or flag)
        'logs',
        'restart',
        'ps',
        'destroy',
        'console',
        'rake',
        'config',
        'env'
      ],
      :compound => [                 # mult-part commands that expect subsequent arguments, must validate extra args on their own
        'create',
        'rake',
        'config',
        'env'
      ]
    }
    
    def initialize(args=[], client='duostack')
      @args = args
      @client = client
    end
    
    def run
      @app_name = parse_app # attempt to get app from args. will also try git repo inference later.
      @flags    = parse_flags
      @command  = @args.shift || COMMANDS[:default]
      
      # we consider this run to be confirmed if the app name has been specified in the args and the --confirm flag is passed
      @confirmed = @app_name && @flags.include?('confirm')
      
      # make sure everything is in order
      validate_args                                       # checks for extraneous args and valid command
      require_app if COMMANDS[:app].include?(@command)    # checks that user is set and app can be ID'd
      require_user if COMMANDS[:user].include?(@command)  # checks user credentials
      
      # everything checks out; time to rock and roll
      send(@command)
    end
    
    
    # argument processing methods
    #########################################################################
    
    # app is special because it's a flag with the next arg containing the app name
    # generally we want to pull this first
    def parse_app
      if app_index = @args.index('--app')
        # slice out app args so we don't re-use them later, returning second element.
        # will be nil if no app name is passed after --app; that's okay.
        @args.slice!(app_index, 2)[1]
      end
    end
    
    # extracts and validates any argument starting with '--', indicating a flag
    def parse_flags
      
      # extract flags
      flags = @args.collect do |arg|
        arg[2..-1] if arg[0..1] == '--'
      end.compact
      
      # remove flags from args
      @args.delete_if { |arg| arg[0..1] == '--' }
      
      return flags
    end
    
    # ensures that the command and all extracted flags are what we expect, warns if they aren't
    def validate_args
      
      invalid = []
      invalid += [@command] - COMMANDS.values.flatten   # validate command
      invalid += @flags - FLAGS                          # validate flags
      
      # unless command is compound (expecting further args), any remaining args must be invalid
      invalid += @args unless COMMANDS[:compound].include?(@command)
      
      if invalid.any?
        exit_with("unrecognized argument: '#{invalid.first}', run '#{@client} help' for usage")
      end
    end
    
    def get_next_args(qty=0, message="missing required argument(s), run '#{@client} help'")
      next_args = @args.shift(qty)
      
      # make sure we got as many args as the caller wanted
      exit_with message unless next_args.length == qty
      
      # de-arrayify if only one
      next_args = next_args.first if next_args.length == 1
      
      return next_args
    end
    
    
    # validation methods
    #########################################################################
    
    # ensures the app can be identified from inspecting the git repo or command line args
    def require_app
      require_user # all app commands require a user
      @app_name ||= extract_app_name
      unless @app_name
        exit_with "run this command from a Duostack app folder or pass an app name with the --app argument"
      end
      return @app_name
    end
    
    # ensures user credentials are cached
    def require_user
      require_ssh_key # all user commands require an SSH key
      
      @credentials ||= `cat ~/.duostack 2>/dev/null`.chomp
      if @credentials.empty? || @credentials[/redirected/]
        puts "First-time Duostack client setup"
        print "Email Address: "
        input_username = $stdin.gets.chomp
        ssh_key = `cat #{@ssh_key}`.chomp
        puts `bash -c 'read -sp "Password: " passwd; echo $passwd > ~/.duostack2'`
        input_password = CGI::escape(`cat ~/.duostack2`.chomp)
        `rm -f ~/.duostack2`
        `curl -m 5 '#{api_host}/api/get_token?api_username=#{CGI::escape(input_username)}&api_password=#{input_password}&ssh_key=#{CGI::escape(ssh_key)}' -o ~/.duostack -s 2>&1 >/dev/null`
        @credentials = `cat ~/.duostack 2>/dev/null`.chomp
        if @credentials.empty? || @credentials[/redirected/] || @credentials.length != 32
          `rm -f ~/.duostack`
          exit_with "authentication error, please try again or contact support@duostack.com"
        end
        `echo 'api_username=#{CGI::escape(input_username)}&api_token=#{@credentials}' > ~/.duostack`
        @credentials = `cat ~/.duostack 2>/dev/null`.chomp
        puts "Completed initial setup... waiting for sync..."
        sleep 4 # TODO: Do a sync check here in the future, 4 secs is safe for now
        puts ""
      end
      
      return @credentials
    end
    
    def require_ssh_key
      @ssh_key ||= extract_ssh_key
      unless @ssh_key
        exit_with "an SSH key is required to run this command, please generate an SSH key and try again (http://docs.duostack.com/command-line-client#setup)"
      end
      return @ssh_key
    end
    
    def require_confirmation
      # NOTE: @confirmed is set above in 'run' so we can be assured the app_name came from the --app flag
      # if assessed confirmation here, the app could have been extracted from the git repo
      unless @confirmed
        exit_with "command requires confirmation, run again with '--confirm --app <appname>'"
      end
    end
    
    
    # utility methods
    #########################################################################
    
    def extract_app_name
      name = `git remote -v 2>&1 | grep -m1 git@duostack.net | grep ".git" | cut -f 2 -d: | cut -f 1 -d.`.chomp
      return name.empty? ? nil : name # ensures nil gets returned instead of an empty string
    end
    
    def extract_ssh_key
      if `file ~/.ssh/id_rsa.pub`[/text|key/]
        '~/.ssh/id_rsa.pub'
      elsif `file ~/.ssh/id_dsa.pub`[/text|key/]
        '~/.ssh/id_dsa.pub'
      elsif `file ~/.ssh/identity.pub`[/text|key/]
        '~/.ssh/identity.pub'
      else
        nil
      end
    end
    
    def api_host
      @api_host ||= begin
        host = "https://duostack.duostack.net"
        if !`curl -V`[/SSL/]
          warn_with "WARNING! curl SSL support is missing, using insecure plaintext mode"
          host = "http://duostack.duostack.net"
        end
        if ENV['DSLOCAL']
          puts "Internal development mode"
          host = "http://localhost:3000"
        end
        host
      end
    end
    
    def api_get(endpoint, params=nil, timeout=20)
      
      url = "#{api_host}/api/#{endpoint}?#{@credentials}"
      
      url += "&app_name=#{@app_name}" if @app_name
      url += "&#{params}" if params
      
      curl_get(url, timeout)
    end
    
    def curl_get(url, timeout=nil)
      command = "curl -sf -A '#{USER_AGENT}' -w '\n%{http_code}' '#{url}'" # use w flag to append http status code
      command += " -m #{timeout}" if timeout
      raw = `#{command}`
      
      debug command
      debug raw
      
      # break apart the raw result and extract the HTTP status code, reassemble
      parts = raw.split("\n")
      status = parts.pop.to_i
      result = parts.join("\n")
      
      # handle 422 codes specially
      # TODO: do this better
      return result if status == 422
      
      case (status / 100) # e.g. any 4xx code will become 4
      when 2 # success, return result sans status code
        return result
      when 1, 3, 4, 5 # the server is doing something dumb (500 error, redirect, 404s)
        exit_with "Duostack API error, please try again or contact support@duostack.com"
      else
        exit_with "could not connect to Duostack API"
      end
    end
    
    def debug(message)
      puts message if ENV['DSDEBUG']
    end
    
    def warn_with(message='error')
      warn "#{@client}: #{message}"
    end
    
    def exit_with(message=nil, code=false)
      warn_with message
      exit code
    end
    
    
    
    # command methods
    #########################################################################
    
    def version
      puts VERSION
    end
    
    def help
      puts <<-EOF
Usage: #{@client} <command> [--app <appname>]

General Commands:          
  create <appname>          Initialize a Git repository as a Duostack app
  list                      Show all associated Duostack apps
  version                   Print version of this Duostack client
                           
App Commands:              
  logs                      Retrieve server logs
  restart                   Restart instances
  ps                        List instances with current status
  destroy                   Destroy Duostack app and associated data
                           
  config <name>             Show configuration option choices and selection
  config <name> <val>       Set configuration option to a value
                           
  env list [--long]         List environment variables
  env add <name>=<val>      Add environment variable
  env remove <name>         Remove environment variable
  env clear                 Clear all environment variables
                           
App Commands - Ruby:       
  console                   Connect to IRB/Rails console
  rake [<command>]          Run a Rake command

EOF
    end
    
    
    def list
      puts api_get('list_apps')
    end
    
    
    def create
      
      # ensure new app name passed, clean up
      name = get_next_args(1, "app name is required, try '#{@client} create <appname>'")
      name = CGI::escape(name.downcase)
      
      # ensure git repo
      if `git status 2>&1`[/Not a git/]
        exit_with "current directory is not a Git repository, run 'git init' first"
      end
      
      # ensure no existing duostack remote
      if extract_app_name
        exit_with "current directory already initialized for Duostack, remove any Git remotes referencing Duostack first"
      end
      
      # create!
      # TODO: ensure there is not already a remote named duostack
      if api_get('create_app', "app_name=#{name}")[/SUCCESS/]
        `git remote add duostack git@duostack.net:#{name}.git`
        puts "Duostack initialized, to push: 'git push duostack master'"
      else
        exit_with "app could not be created, please check that app name is valid and available"
      end
    end
    
    
    def logs
      result = api_get('get_logs')
      if result[/\.log/]
        puts result
      else
        exit_with "no logs found"
      end
    end
    
    
    def restart
      if api_get('restart')[/SUCCESS/]
        puts "App restarted"
      else
        exit_with "unable to restart app"
      end
    end
    
    
    def ps
      result = api_get('get_instances')
      if result[/Instance ID|Status/]
        puts result
      else
        exit_with "unable to get instances"
      end
    end
    
    
    def destroy
      require_confirmation
      
      # pull out remote name before we destroy
      remote = `git remote show duostack 2>/dev/null`
      
      # destroy!
      if api_get("delete_app")[/SUCCESS/]
        # attempt to remove duostack git remote
        # only if "duostack" remote actually references this app's remote
        if !remote.empty? and remote.scan("git@duostack.net:#{app}.git").length > 0
          `git remote rm duostack 2>/dev/null`
        end
        
        puts "App destroyed"
        
      else
        exit_with "unable to destroy app, please try again or contact support@duostack.com"
      end
    end
    
    
    def console
      exec(".duostack-console-expect #{@app_name}")
    end
    
    
    def rake
      
      # get command(s), if they exist (all remaining args), clean up
      command = @args.join(' ')
      command = CGI::escape(command)
      
      result = api_get('run_rake', "command=#{command}", 60)
      
      if result[/\n/]
        puts result
      else
        exit_with "unable to run rake task, please try again or contact support@duostack.com"
      end
    end
    
    
    def config
      
      name  = get_next_args(1, "option name is required, try '#{@client} config <name> [<value>]'")
      value = @args.shift
      
      name  = CGI::escape(name)
      value = CGI::escape(value) if value
      
      if value # value provided, set config
        result = api_get('option_set', "name=#{name}&val=#{value}")
        if result[/\n/]
          puts result
        else
          exit_with "unable to set config option"
        end
        
      else # no value provided, get config
        result = api_get('option_get', "name=#{name}")
        if result[/\n/]
          puts result
        else
          exit_with "unable to set config option"
        end
      end
    end
    
    
    # TODO: generalize this, because there will be other CRUD commands in the future
    def env
      
      # get command
      command = @args.shift
      command ||= 'list' # list is the default
      
      # ensure command is valid
      unless %w(add remove rm list ls clear).include?(command)
        exit_with "invalid argument for 'env', try list, add, remove, or clear"
      end
      
      # ensure we have an argument for add/remove commands which require it
      if %w(add remove rm).include?(command)
        # gather up and compose subsequent args for add/remove operations
        # takes all remaining arguments. recompose strings because ruby strips out quotation marks in the args.
        argument = @args.collect do |arg|
          if arg.include?('=')
            result = arg.split('=',2)
            %Q(#{result[0]}="#{result[1].gsub('"', '\"')}")
          else
            arg
          end
        end.join(' ')
        @args.clear # clean up, since we processed every remaining arg
        
        # warn and exit unless we have an argument to pass
        if argument.empty?
          case command
          when 'add'
            exit_with "'env add' requires an argument, try 'env add <name>=<value>'"
          when 'remove', 'rm'
            exit_with "'env #{command}' requires an argument, try 'env #{command} <name>'"
          end
        end
        
        # clean up argument
        argument = CGI::escape(argument)
      end
      
      # finally, process command
      case command
      when 'list', 'ls'
        truncate = !@flags.include?('long')
        result = api_get("list_envs", "truncate=#{truncate}")
        unless result == 'API Error'
          print result
        else
          exit_with "unable to list environment variables"
        end
      
      when 'add'
        result = api_get("add_env", "input=#{argument}")
        unless result == 'API Error'
          puts result
        else
          exit_with "unable to add environment variable(s)"
        end
      
      when 'remove', 'rm'
        result = api_get("remove_env", "name=#{argument}")
        if result[/SUCCESS/]
          puts "Environment variable(s) removed"
        else
          exit_with "unable to remove environment variable(s)"
        end
      
      when 'clear'
        require_confirmation
        
        result = api_get("clear_envs")
        if result[/SUCCESS/]
          puts "Environment variables cleared"
        else
          exit_with "unable to clear environment variables"
        end
      else
        exit false # this shouldn't happen
      end
      
    end
    
  end
end


Duostack::Client.new(ARGV.dup, File.basename(__FILE__)).run
