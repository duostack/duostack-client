#!/usr/bin/env ruby
require 'cgi'
$dir = File.dirname(File.expand_path(__FILE__))
$client = File.basename(__FILE__)

module Duostack
  class Client
    
    VERSION = '0.1.0'
    DEPENDENCIES_LAST_MODIFIED = 1297154481
    DEFAULT_CREDENTIALS_LOCATION = '~/.duostack'
    USER_AGENT = "duostack-#{VERSION}"
    
    FLAGS = [                        # app is one too but gets special handling
      'confirm',
      'long',
      'skip-dependency-checks'
    ]
    
    COMMANDS = {
      :default => 'help',            # command used when no other command is given
      :general => %w(version help),  # general commands, can always be run
      :user    => [                  # commands requiring credentials (first-time setup)
        'create',
        'list',
        'sync'
      ],
      :app     => [                  # commands requiring an app to be specified (either by git inference or flag)
        'logs',
        'restart',
        'ps',
        'destroy',
        'console',
        'rake',
        'config',
        'env'
      ],
      :compound => [                 # mult-part commands that expect subsequent arguments, must validate extra args on their own
        'help',
        'create',
        'rake',
        'config',
        'env'
      ]
    }
    
    def initialize(args=[], client='duostack')
      @args = args
      @client = client
    end
    
    def run
      @creds_file = get_flag_arg('creds') || DEFAULT_CREDENTIALS_LOCATION
      @app_name   = get_flag_arg('app') # attempt to get app from args. will also try git repo inference later.
      @flags      = parse_flags
      @command    = @args.shift || COMMANDS[:default]
      
      # we consider this run to be confirmed if the app name has been specified in the args and the --confirm flag is passed
      @confirmed = @app_name && @flags.include?('confirm')
      
      # make sure everything is in order
      check_dependencies unless @flags.include?('skip-dependency-checks')
      validate_args                                       # checks for extraneous args and valid command
      require_app if COMMANDS[:app].include?(@command)    # checks that user is set and app can be ID'd
      require_user if COMMANDS[:user].include?(@command)  # checks user credentials
      
      # everything checks out; time to rock and roll
      send(@command)
    end
    
    
    # argument processing methods
    #########################################################################
    
    # extracts and validates any argument starting with '--', indicating a flag
    def parse_flags
      
      # extract flags
      flags = @args.collect do |arg|
        arg[2..-1] if arg[0..1] == '--'
      end.compact
      
      # remove flags from args
      @args.delete_if { |arg| arg[0..1] == '--' }
      
      return flags
    end
    
    # ensures that the command and all extracted flags are what we expect, warns if they aren't
    def validate_args
      
      invalid = []
      invalid += [@command] - COMMANDS.values.flatten   # validate command
      invalid += @flags - FLAGS                          # validate flags
      
      # unless command is compound (expecting further args), any remaining args must be invalid
      invalid += @args unless COMMANDS[:compound].include?(@command)
      
      if invalid.any?
        exit_with("unrecognized argument: '#{invalid.first}', run '#{@client} help' for usage")
      end
    end
    
    def get_next_args(qty=0, message="missing required argument(s), run '#{@client} help'")
      next_args = @args.shift(qty)
      
      # make sure we got as many args as the caller wanted
      exit_with message unless next_args.length == qty
      
      # de-arrayify if only one
      next_args = next_args.first if next_args.length == 1
      
      return next_args
    end
    
    # used to read flags followed by an argument (e.g. --app)
    # returns the arg following the flag of "name" or nil
    def get_flag_arg(flag)
      if flag_index = @args.index("--#{flag}")
        # slice out flag args so we don't re-use them later, returning second element
        # will be nil if no arg is passed after --flag; that's okay
        @args.slice!(flag_index, 2)[1]
      end
    end
    
    
    # validation methods
    #########################################################################
    
    def check_dependencies
      
      filename = File.expand_path(@creds_file)
      return if File.exist?(filename) && File.mtime(filename).to_i > DEPENDENCIES_LAST_MODIFIED
      
      # ruby
      if `which ruby`.empty? # how are we even here?
        exit_with "missing dependency, please install Ruby 1.8.6 or later"
      end
      
      # ruby >= 1.8.6
      if `ruby -v`.split[1].to_f < 1.8
        exit_with "missing dependency, please install Ruby 1.8.6 or later"
      end
      
      # git (any)
      if `which git`.empty?
        exit_with "missing dependency, please install Git"
      end
      
      # curl
      if `which curl`.empty?
        exit_with "missing dependency, please install curl (http://curl.haxx.se/download.html)"
      end
      
      # curl SSL
      # handled inside api_host method
      
      # expect (only if running console)
      # TODO: just use ruby expect lib
      if @command == 'console' && `which expect`.empty?
        exit_with "missing dependency, please install Expect"
      end
      
      # touch .duostack so we know when deps were last checked (but don't create it if it doesn't exist)
      require 'fileutils'
      FileUtils.touch(filename) if File.exist?(filename)
      
    end
    
    # ensures the app can be identified from inspecting the git repo or command line args
    def require_app
      require_user # all app commands require a user
      @app_name ||= extract_app_name
      unless @app_name
        exit_with "run this command from a Duostack app folder or pass an app name with the --app argument"
      end
      return @app_name
    end
    
    # ensures user credentials are cached
    def require_user
      @credentials ||= `cat #{@creds_file} 2>/dev/null`.chomp
      
      if @credentials.empty?
        ssh_key = require_ssh_key # all user commands require an SSH key
        
        puts "First-time Duostack client setup"
        print "Email Address: "
        username = $stdin.gets.chomp
        password = `bash -c 'read -sp "Password: " passwd; echo $passwd'`.chomp
        puts '' # clears the line after
        
        username = CGI::escape(username)
        password = CGI::escape(password)
        ssh_key  = CGI::escape(ssh_key)
        
        api_token = api_get('get_token', "api_username=#{username}&api_password=#{password}&ssh_key=#{ssh_key}", 5)
        `echo 'api_username=#{username}&api_token=#{api_token}' > #{@creds_file}`
        `chmod 600 #{@creds_file}`
        @credentials = `cat #{@creds_file} 2>/dev/null`.chomp
        if @credentials.empty? || @credentials.length < 32 # at least the length of the token
          exit_with "error saving credentials file, please contact support@duostack.com"
        end
        puts "Completed initial setup... waiting for sync..."
        sleep 4 # TODO: Do a sync check here in the future, 4 secs is safe for now
        puts ""
      end
      
      return @credentials
    end
    
    def require_ssh_key
      @ssh_key ||= `cat #{ssh_key_location}`.chomp
      unless @ssh_key
        exit_with "an SSH key is required to run this command, please generate an SSH key and try again (http://docs.duostack.com/command-line-client#setup)"
      end
      return @ssh_key
    end
    
    def require_confirmation
      # NOTE: @confirmed is set above in 'run' so we can be assured the app_name came from the --app flag
      # if assessed confirmation here, the app could have been extracted from the git repo
      unless @confirmed
        exit_with "command requires confirmation, run again with '--confirm --app <appname>'"
      end
    end
    
    
    # utility methods
    #########################################################################
    
    def extract_app_name
      name = `git remote -v 2>&1 | grep -m1 git@duostack.net | grep ".git" | cut -f 2 -d: | cut -f 1 -d.`.chomp
      return name.empty? ? nil : name # ensures nil gets returned instead of an empty string
    end
    
    def ssh_key_location
      if `file ~/.ssh/id_rsa.pub`[/text|key/]
        '~/.ssh/id_rsa.pub'
      elsif `file ~/.ssh/id_dsa.pub`[/text|key/]
        '~/.ssh/id_dsa.pub'
      elsif `file ~/.ssh/identity.pub`[/text|key/]
        '~/.ssh/identity.pub'
      else
        nil
      end
    end
    
    def api_host
      @api_host ||= begin
        host = "https://duostack.duostack.net"
        if !`curl -V`[/SSL/]
          warn_with "WARNING! curl SSL support is missing, using insecure plaintext mode"
          host = "http://duostack.duostack.net"
        end
        if ENV['DSLOCAL']
          puts "Internal development mode"
          host = "http://localhost:3000"
        end
        host
      end
    end
    
    def api_get(endpoint, params=nil, timeout=20)
      
      url = "#{api_host}/api/#{endpoint}?#{@credentials}"
      
      url += "&app_name=#{@app_name}" if @app_name
      url += "&#{params}" if params
      
      curl_get(url, timeout)
    end
    
    def curl_get(url, timeout=nil)
      command = "curl -sf -A '#{USER_AGENT}' -w '\n%{http_code}' '#{url}'" # use w flag to append http status code
      command += " -m #{timeout}" if timeout
      raw = `#{command}`
      
      debug command
      debug raw
      
      # break apart the raw result and extract the HTTP status code, reassemble
      parts = raw.split("\n")
      status = parts.pop.to_i
      result = parts.join("\n")
      
      # if the code is 422, we should have a displayable error message, so display directly
      if status == 422
        exit_with result
      end
      
      case (status / 100) # just get the class of status, e.g. any 4xx code will become 4
      when 2 # success, return result sans status code
        return result
      when 1, 3, 4, 5 # the server is doing something dumb (500 error, redirect, 404s)
        exit_with "Duostack API error, please try again or contact support@duostack.com"
      else
        exit_with "could not connect to Duostack API"
      end
    end
    
    def debug(message)
      puts message if ENV['DSDEBUG']
    end
    
    def warn_with(message='error')
      warn "#{@client}: #{message}"
    end
    
    def exit_with(message=nil, code=false)
      warn_with message
      exit code
    end
    
    
    
    # command methods
    #########################################################################
    
    def version
      puts VERSION
    end
    
    def help
      if content = Help.read_section(@args.shift)
        puts content
      else
        exit_with "unrecognized help section, try '#{@client} help'"
      end 
    end
    
    def sync
      # empty method, just makes sure credentials are set
    end
    
    def list
      puts api_get('list_apps')
    end
    
    
    def create
      
      # ensure new app name passed, clean up
      name = get_next_args(1, "app name is required, try '#{@client} create <appname>'")
      name = CGI::escape(name.downcase)
      
      # ensure git repo
      if `git status 2>&1`[/Not a git/]
        exit_with "current directory is not a Git repository, run 'git init' first"
      end
      
      # ensure no existing duostack remote
      if extract_app_name
        exit_with "current directory already initialized for Duostack, remove any Git remotes referencing Duostack first"
      end
      
      # create!
      # TODO: ensure there is not already a remote named duostack
      puts api_get('create_app', "app_name=#{name}")
      `git remote add duostack git@duostack.net:#{name}.git 2>/dev/null`
      puts "Git remote added, to push: 'git push duostack master'"
    end
    
    
    def logs
      puts api_get('get_logs')
    end
    
    
    def restart
      puts api_get('restart')
    end
    
    
    def ps
      puts api_get('get_instances')
    end
    
    
    def destroy
      require_confirmation
      
      # pull out remote name before we destroy
      remote = `git remote show duostack 2>/dev/null`
      
      # destroy!
      puts api_get("delete_app")
      
      # attempt to remove duostack git remote
      # only if "duostack" remote actually references this app's remote
      if !remote.empty? and remote.scan("git@duostack.net:#{app}.git").length > 0
        `git remote rm duostack 2>/dev/null`
      end
    end
    
    
    def console
      exec("#{$dir}/.duostack-console-expect #{@app_name}")
    end
    
    
    def rake
      
      # get command(s), if they exist (all remaining args), clean up
      command = @args.join(' ')
      command = CGI::escape(command)
      
      puts api_get('run_rake', "command=#{command}", 60)
    end
    
    
    def config
      
      name  = get_next_args(1, "option name is required, try '#{@client} config <name> [<setting>]'")
      value = @args.shift
      
      name  = CGI::escape(name)
      value = CGI::escape(value) if value
      
      if value # value provided, set config
        puts api_get('option_set', "name=#{name}&val=#{value}")
      else # no value provided, get config
        puts api_get('option_get', "name=#{name}")
      end
    end
    
    
    # TODO: generalize this, because there will be other CRUD commands in the future
    def env
      
      # get command
      command = @args.shift
      command ||= 'list' # list is the default
      
      # ensure command is valid
      unless %w(add remove rm list ls clear).include?(command)
        exit_with "invalid argument for 'env', try list, add, remove, or clear"
      end
      
      # ensure we have an argument for add/remove commands which require it
      if %w(add remove rm).include?(command)
        # gather up and compose subsequent args for add/remove operations
        # takes all remaining arguments. recompose strings because ruby strips out quotation marks in the args.
        argument = @args.collect do |arg|
          if arg.include?('=')
            result = arg.split('=',2)
            %Q(#{result[0]}="#{result[1].gsub('"', '\"')}")
          else
            arg
          end
        end.join(' ')
        @args.clear # clean up, since we processed every remaining arg
        
        # warn and exit unless we have an argument to pass
        if argument.empty?
          case command
          when 'add'
            exit_with "'env add' requires an argument, try 'env add <name>=<value>'"
          when 'remove', 'rm'
            exit_with "'env #{command}' requires an argument, try 'env #{command} <name>'"
          end
        end
        
        # clean up argument
        argument = CGI::escape(argument)
      end
      
      # finally, process command
      case command
      when 'list', 'ls'
        truncate = !@flags.include?('long')
        print api_get("list_envs", "truncate=#{truncate}")
      when 'add'
        puts api_get("add_env", "input=#{argument}")
      when 'remove', 'rm'
        puts api_get("remove_env", "name=#{argument}")
      when 'clear'
        require_confirmation
        puts api_get("clear_envs")
      else
        exit false # this shouldn't happen
      end
    end
    
    
    
    module Help
      
      # available help sections. first will be used as the default.
      SECTIONS = %w(help create list version logs restart ps destroy config env console rake)
      
      class << self
        
        def read_section(section)
          
          # use default if not set
          section ||= SECTIONS.first
          
          # validate section exists
          return false unless SECTIONS.include?(section)
          
          self.send(section).gsub(/\n\s{12}/, "\n") # strips leading spaces so we can keep these indented
        end
        
        def help
          <<-EOF
            
            Usage: #{$client} <command> [<args>] [--app <appname>]
            
            The most common commands are listed below.
            For additional information on any of them, run: #{$client} help <command>
            
            General Commands:
              help [<command>]          Show this help, or detailed help on <command>
              create <appname>          Initialize a Git repository as a Duostack App
              list                      Show all associated Duostack Apps
              version                   Show version of this Duostack client
            
            App Commands:
              logs                      Retrieve server logs
              restart                   Restart instances
              ps                        List instances with current status
              destroy                   Destroy Duostack App and associated data
              config <name> [<setting>] Show or set configuration options
              env [<operation>]         Manage environment variables
            
            App Commands - Ruby:
              console                   Connect to IRB/Rails console
              rake [<command>]          Run a Rake command
            
          EOF
        end
        
        def create
          <<-EOF
            
            Usage: #{$client} create <appname>
            
            Arguments:
              <appname>       A name for your app (restrictions apply, see below)
            
            Creates a new Duostack App from the current directory with the given name.
            
            The current directory must be initialized as a Git repository (run 'git init').
            Upon running 'create', the app will be created on Duostack and a Git remote with
            the name 'duostack' will be added to the local repository, which you can push to
            to deploy your app: git push duostack master.
            
            The app name must be 4-16 characters long, alphanumeric, and must not start with
            a number. The use of hyphens, underscores, or any other special characters is
            not supported.
            
          EOF
        end
        
        def list
          <<-EOF
            
            Usage: #{$client} list
            
            Shows a list of the apps associated with your Duostack account.
            
          EOF
        end
        
        def version
          <<-EOF
            
            Usage: #{$client} version
            
            Displays the client's version number.
            
          EOF
        end
        
        def logs
          <<-EOF
            
            Usage: #{$client} logs [--app <appname>]
            
            Retreives aggregate logs from all of the app's instances.
            
            The app to operate on is determined first from the command line '--app' flag, or
            if none is specified, by looking for a Git remote in the current folder that
            references Duostack.
            
          EOF
        end
        
        def restart
          <<-EOF
            
            Usage: #{$client} restart [--app <appname>]
            
            Restarts all the app's instances. This will cause the app to pick up any changes
            to its configuration options or environment variables made with the 'config' or
            'env' commands. Apps are automatically restarted after each Git push.
            
            The app to operate on is determined first from the command line '--app' flag, or
            if none is specified, by looking for a Git remote in the current folder that
            references Duostack.
            
          EOF
        end
        
        def ps
          <<-EOF
            
            Usage: #{$client} ps [--app <appname>]
            
            Retreives a listing of all the app's instances with status information (uptime)
            for each.
            
            The app to operate on is determined first from the command line '--app' flag, or
            if none is specified, by looking for a Git remote in the current folder that
            references Duostack.
            
          EOF
        end
        
        def destroy
          <<-EOF
            
            Usage: #{$client} destroy [--app <appname>] [--confirm]
            
            Destroys the app and all associated data. Can not be undone; use with caution.
            
            Requires confirmation.
            
            The app to operate on is determined first from the command line '--app' flag, or
            if none is specified, by looking for a Git remote in the current folder that
            references Duostack.
            
          EOF
        end
        
        def config
          <<-EOF
            
            Usage:
              #{$client} config [--app <appname>]                     list configs
              #{$client} config <name> [--app <appname>]              show config
              #{$client} config <name> <setting> [--app <appname>]    set config
            
            Lists, shows, and sets app config options.
            
            List Configs: Shows a list of all available config option names with their
            current settings.
            
            Show Config: Shows a list of the valid settings for the config option <name>.
            <name> must be one of the available options shown in the list of configs. The
            currently selected value is denoted with an asterisk next to it.
            
            Set Config: Allows setting of config options. Sets config <name> to <setting>.
            <setting> must be one of the valid settings shown for this config.
            
            The app to operate on is determined first from the command line '--app' flag, or
            if none is specified, by looking for a Git remote in the current folder that
            references Duostack.

            
            Usage: #{$client} config [--app <appname>]
            
            Shows a list of all available config option names with their current settings.
            
            Usage: #{$client} config <name> [--app <appname>]
            
            Shows a list of the valid values for the config option with name <name>. <name>
            must be one of the available options shown in the list of names when running
            'config' with no arguments. The currently selected value is denoted with an
            asterisk next to it.
            
            Usage: #{$client} config <name> <setting> [--app <appname>]
            
            
            
            
            
            
            Usage:
              1. #{$client} config [--app <appname>]                   list configs
              2. #{$client} config <name> [--app <appname>]            show config
              3. #{$client} config <name> <setting> [--app <appname>]  set config
            
            Arguments:
              <name>     name of the config option to show/set, must be one of the available
                         configs shown in the list from '#{$client} config'
              <setting>  setting to set for config option <name>, must be one of the valid
                         settings shown in the list from '#{$client} config <name>'
            
            Lists, shows, and sets app config options.
            
            Running 'config' with no arguments will list all available config options with
            their current settings.
            
            Running 'config <name>' will display a list of 
            
          EOF
        end
        
        def env
          <<-EOF
            
            Usage:
              #{$client} env [--long] [--app <appname>]                 list env vars
              #{$client} env add <name>=<value> [--app <appname>]       add env var
              #{$client} env remove <name> [--app <appname>]            remove env var
              #{$client} env clear [--app <appname>] [--confirm]        clear env vars
            
            Lists, adds, removes, and clears app environment variables.
            
            List: Lists environment variables currently set on the app. If none are set,
            output will be blank. List output is abbreviated by default for readability. If
            you need to see the full values of your environment variables, use the --long
            flag with this command.
            
            Add: Add one or more environment variables to the app. Add multiple by
            supplying additional <name>=<value> pairs separated by spaces. You may need to 
            quote any complex values (with spaces or special characters) that may confuse
            the client or your shell.
            
            Remove: Removes one or more environment variables from the app. Remove multiple
            by supplying additional variable <name> arguments separated by spaces.
            
            Clear: Clears all environment variables from the app. Requires confirmation.
            
            The app to operate on is determined first from the command line '--app' flag, or
            if none is specified, by looking for a Git remote in the current folder that
            references Duostack.
            
          EOF
        end
        
        def console
          <<-EOF
            
            Usage: #{$client} console [--app <appname>]
            
            Launches an interactive IRB/console session with your app. You can use this to
            make any action you would normally make in your app's console.
            
            Applicable only to Ruby applications.
            
            The app to operate on is determined first from the command line '--app' flag, or
            if none is specified, by looking for a Git remote in the current folder that
            references Duostack.
            
          EOF
        end
        
        def rake
          <<-EOF
            
            Usage: #{$client} rake [<command>] [--app <appname>]
            
            Runs rake (with an optional <command> argument) on your app. After the task has
            run, the output will be displayed. Tasks running longer than 60 seconds will not
            have their full output displayed.
            
            Applicable only to Ruby applications.
            
            The app to operate on is determined first from the command line '--app' flag, or
            if none is specified, by looking for a Git remote in the current folder that
            references Duostack.
            
          EOF
        end
        
        
      end
    end
    
  end
end


Duostack::Client.new(ARGV.dup, $client).run
