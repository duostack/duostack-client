#!/usr/bin/env ruby
require 'cgi'

module Duostack
  class Client
    
    VERSION = '0.1'
    
    FLAGS = ['confirm', 'long']      # app is one too but gets special handling
    
    COMMANDS = {
      :default => 'help',            # command used when no other command is given
      :general => %w(version help),  # general commands, can always be run
      :user    => %w(create list),   # commands requiring a credentials (first-time setup)
      :app     => [                  # commands requiring an app to be specified (either by git inference or flag)
        'logs',
        'restart',
        'ps',
        'destroy',
        'console',
        'rake',
        'config',
        'env'
      ],
      :compound => [                 # mult-part commands that expect subsequent arguments, must validate extra args on their own
        'rake',
        'config',
        'env'
      ]
    }
    
    def initialize(args=[], client='duostack')
      @args = args
      @client = client
    end
    
    def run
      @app_name = parse_app # first pass at getting app. will also try git repo inference later.
      @flags    = parse_flags
      @command  = @args.shift || COMMANDS[:default]
      
      validate_args
    end
    
    # app is special because it's a flag with the next arg containing the app name
    # generally we want to pull this first
    def parse_app
      if app_index = @args.index('--app')
        # slice out app args so we don't re-use them later, returning second element.
        # will be nil if no app name is passed after --app; that's okay.
        @args.slice!(app_index, 2)[1]
      end
    end
    
    # extracts and validates any argument starting with '--', indicating a flag
    def parse_flags
      
      # extract flags
      flags = @args.collect do |arg|
        arg[2..-1] if arg[0..1] == '--'
      end.compact
      
      # remove flags from args
      @args.delete_if { |arg| arg[0..1] == '--' }
      
      return flags
    end
    
    # ensures that the command and all extracted flags are what we expect, warns if they aren't
    def validate_args
      
      invalid = []
      invalid += [@command] - COMMANDS.values.flatten   # validate command
      invalid += @flags - FLAGS                          # validate flags
      
      # unless command is compound (expecting further args), any remaining args must be invalid
      invalid += @args unless COMMANDS[:compound].include?(@command)
      
      if invalid.any?
        exit_with("unrecognized argument: '#{invalid.first}', run '#{@client} help' for usage")
      end
    end
    
    
    # utility methods
    #########################################################################
    
    def debug(message)
      puts message if ENV['DSDEBUG']
    end
    
    def exit_with(message='error', code=false)
      warn "#{@client}: #{message}"
      exit code
    end
    
  end
end


Duostack::Client.new(ARGV.dup, File.basename(__FILE__)).run


exit


# parse app name out of arguments
app = if app_index = ARGV.index('--app')
  app_name_source = :flag
  # slice out app args so we don't re-use them later, returning second element.
  # will be nil if no app name is passed after --app; that's okay.
  ARGV.slice!(app_index, 2)[1]
else
  app_name_source = :git_remote
  # fall back to parsing out of duostack git remote
  `git remote -v 2>&1 | grep -m1 git@duostack.net | grep ".git" | cut -f 2 -d: | cut -f 1 -d.`.chomp
end

# pull flags out of arguments (has to happen after app flag is extracted)
flags = ARGV.select { |arg| arg[0..1] == '--' }
ARGV.delete_if { |arg| flags.include?(arg) }

# parse out confirmedness
$confirmed = app_name_source == :flag && flags.delete('--confirm')
def require_confirmation
  unless $confirmed
    warn "#{$client}: command requires confirmation, run again with '--confirm --app <appname>'"
    exit false
  end
end

# parse out CRUD commands (two-part commands)
command_noun, command_verb, command_argument = [nil]*3
['env'].each do |command_candidate|
  
  # look for any instances of CRUD commands
  if command_index = ARGV.index(command_candidate)
    command_noun = command_candidate
    command_verb = if %w(add remove rm list ls clear).include?(ARGV[command_index+1])
      ARGV[command_index+1]
    else
      'list' # default command
    end
    command_argument = if %w(add remove rm).include?(command_verb)
      # takes all following arguments. recompose strings because ruby strips out quotation marks in the args.
      ARGV[(command_index+2)..-1].collect do |arg|
        if arg.include?('=')
          result = arg.split('=',2)
          %Q(#{result[0]}="#{result[1].gsub('"', '\"')}")
        else
          arg
        end
      end.join(' ')
    end
    ARGV.slice!(command_index..-1) # clear args we've handled out of array
    break
  end
end


if ARGV.length > 0 && ARGV[0] == "version"
  puts "0.0.10"
  exit
end

if `file ~/.ssh/id_rsa.pub`[/text|key/]
  idfile = '~/.ssh/id_rsa.pub'
elsif `file ~/.ssh/id_dsa.pub`[/text|key/]
  idfile = '~/.ssh/id_dsa.pub'
elsif `file ~/.ssh/identity.pub`[/text|key/]
  idfile = '~/.ssh/identity.pub'
else
  warn "#{$client}: generate an SSH key before running this client"
  exit false
end

$api_host = "https://duostack.duostack.net"
if !`curl -V`[/SSL/]
  $api_host = "http://duostack.duostack.net"
  warn "#{$client}: insecure plaintext mode because curl SSL support is missing"
end
$api_host = "http://localhost:3000" if ENV['DSLOCAL']
puts "Internal development mode" if ENV['DSLOCAL']

$credentials=`cat ~/.duostack 2>/dev/null`.chomp
if $credentials.empty? || $credentials[/redirected/]
  puts "First-time Duostack client setup"
  print "Email Address: "
  input_username = $stdin.gets.chomp
  ssh_key = `cat #{idfile}`.chomp
  puts `bash -c 'read -sp "Password: " passwd; echo $passwd > ~/.duostack2'`
  input_password = CGI::escape(`cat ~/.duostack2`.chomp)
  `rm -f ~/.duostack2`
  `curl -m 5 "#{$api_host}/api/get_token?api_username=#{CGI::escape(input_username)}&api_password=#{input_password}&ssh_key=#{CGI::escape(ssh_key)}" -o ~/.duostack -s 2>&1 >/dev/null`
  $credentials=`cat ~/.duostack 2>/dev/null`.chomp
  if $credentials.empty? || $credentials[/redirected/] || $credentials.length != 32
    puts "Authentication error, please try again"
    `rm -f ~/.duostack`
    exit false
  end
  `echo 'api_username=#{CGI::escape(input_username)}&api_token=#{$credentials}' > ~/.duostack`
  $credentials=`cat ~/.duostack 2>/dev/null`.chomp
  puts "Completed initial setup... waiting for sync..."
  # Do a sync check here in the future, 4 secs is safe for now
  sleep 4
  puts ""
end

def api_get(url)
  debug = `echo curl -m 30 -w '\n%{http_code}' "#{$api_host}/#{url}&#{$credentials}" -sf`
  result = `curl -m 30 -w '\n%{http_code}' "#{$api_host}/#{url}&#{$credentials}" -sf`
  debug += result
  puts debug if ENV['DSDEBUG']
  
  result = result.split("\n")
  if result.last != '200'
    return "API Error"
  else
    return result[0..-2].join("\n")
  end
end

if (!command_noun && ARGV.length == 0) || ARGV[0] == "help"
  puts <<-EOF
Usage: #{$client} <command> [--app <appname>]

General Commands:          
  create <appname>          Initialize a Git repository as a Duostack app
  list                      Show all associated Duostack apps
  version                   Print version of this Duostack client
                           
App Commands:              
  logs                      Retrieve server logs
  restart                   Restart instances
  ps                        List instances with current status
  destroy                   Destroy Duostack app and associated data
                           
  config <name>             Show configuration option choices and selection
  config <name> <val>       Set configuration option to a value
                           
  env list [--long]         List environment variables
  env add <name>=<val>      Add environment variable
  env remove <name>         Remove environment variable
  env clear                 Clear all environment variables
                           
App Commands - Ruby:       
  console                   Connect to IRB/Rails console
  rake <command>            Run a Rake command

EOF
  exit
end

if ARGV[0] == "list"
  result = api_get("api/list_apps?1")
  unless result == 'API Error'
    puts result
    exit
  else
    warn "#{$client}: no apps found"
    exit false
  end
end

if ARGV[0] == "create"
  if ARGV.length < 2
    warn "#{$client}: try '#{$client} create <app name>'"
    exit false
  end
  if `git status 2>&1`[/Not a git/]
    warn "#{$client}: initialize Git repository before using create"
    exit false
  end
  if !app.empty?
    warn "#{$client}: this repository is already initialized for Duostack"
    exit false
  end
  # check if remote duostack already exists in the future
  if api_get("api/create_app?app_name=#{CGI::escape(ARGV[1].downcase)}")[/SUCCESS/]
    `git remote add duostack git@duostack.net:#{CGI::escape(ARGV[1].downcase)}.git`
    puts "Duostack initialized. To push: git push duostack master"
    exit
  else
    puts "This app name is unavailable. Please try another."
    exit false
  end
end




# anything beyond this point is an app command, so require the app to be specified
if app.nil? or app.empty?
  warn "#{$client}: run this command from a Duostack app folder or pass an app name with the --app argument"
  exit false  
end

if command_noun == 'env'
  
  case command_verb
  when 'list', 'ls'
    truncate = !flags.delete('--long')
    result = api_get("api/list_envs?app_name=#{app}&truncate=#{truncate}")
    unless result == 'API Error'
      print result
      exit
    else
      puts "Unable to list environment variables"
      exit false
    end
    
  when 'add'
    result = api_get("api/add_env?app_name=#{app}&input=#{CGI::escape(command_argument)}")
    unless result == 'API Error'
      puts result
      exit
    else
      puts "Unable to add environment variable(s)"
      exit false
    end
    
  when 'remove', 'rm'
    result = api_get("api/remove_env?app_name=#{app}&name=#{CGI::escape(command_argument)}")
    if result[/SUCCESS/]
      puts "Environment variable(s) removed"
      exit
    else
      puts "Unable to remove environment variable(s)"
      exit false
    end
    
  when 'clear'
    require_confirmation
    
    result = api_get("api/clear_envs?app_name=#{app}")
    if result[/SUCCESS/]
      puts "Environment variables cleared"
      exit
    else
      puts "Unable to clear environment variables"
      exit false
    end
  else
    exit false # this shouldn't happen
  end
end


if ARGV[0] == "config"
  
  name, value = ARGV[1..2] # value will be nil if there is no ARGV[2]
  
  if name
    if value
      result = api_get("api/option_set?app_name=#{app}&name=#{name}&val=#{value}")
      unless result == 'API Error'
        puts result
        exit
      else
        puts "Unable to set config option"
        exit false
      end
      
    else
      # no value given, get option list
      result = api_get("api/option_get?app_name=#{app}&name=#{name}")
      unless result == 'API Error'
        puts result
        exit
      else
        puts "Unable to get config option"
        exit false
      end
    end
    
  else
    warn "#{$client}: try '#{$client} config <name> <value>'"
    exit false
  end
  
end


if ARGV[0] == "console"
  exec(".duostack-console-expect #{app}")
  exit
end

if ARGV[0] == "rake"
  if ARGV.length < 2
    warn "#{$client}: try '#{$client} rake <command>'"
    exit false
  end
  # Need this to go longer
  result = `curl -m 60 "#{$api_host}/api/run_rake?app_name=#{app}&command=#{CGI::escape(ARGV[1,999].join(' '))}&#{$credentials}" -s`
  if result[/\n/]
    puts result
    exit
  else
    puts "Unable to run rake task"
    exit false
  end
end

if ARGV[0] == "restart"
  get_log = api_get("api/restart?app_name=#{app}")
  if get_log[/SUCCESS/]
    puts "App restarted"
    exit
  else
    puts "Unable to restart app"
    exit false
  end
end

if ARGV[0] == "logs"
  get_log = api_get("api/get_logs?app_name=#{app}")
  if get_log[/\.log/]
    puts get_log
    exit
  else
    warn "#{$client}: no logs found"
    exit false
  end
end

if ARGV[0] == "ps"
  result = api_get("api/get_instances?app_name=#{app}")
  if result[/Instance ID|Status/]
    puts result
    exit
  else
    warn "#{$client}: unable to get instances"
    exit false
  end
end

if ARGV[0] == "destroy"
  
  require_confirmation
  
  remote = `git remote show duostack 2>/dev/null`     # pull out remote name before we destroy
  result = api_get("api/delete_app?app_name=#{app}")  # destroy
  
  if result[/SUCCESS/]
    # attempt to remove duostack git remote
    # only if "duostack" remote actually references this app's remote
    if !remote.empty? and remote.scan("git@duostack.net:#{app}.git").length > 0
      `git remote rm duostack 2>/dev/null`
    end
    
    puts "App destroyed"
    exit
  else
    puts "Unable to destroy app"
    exit false
  end

end

puts "#{$client}: for usage, run '#{$client}' without arguments"
exit false
