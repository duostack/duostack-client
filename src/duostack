#!/usr/bin/env ruby
require 'cgi'

module Duostack
  class Client
    
    VERSION = '0.1.0'
    
    FLAGS = ['confirm', 'long']      # app is one too but gets special handling
    
    COMMANDS = {
      :default => 'help',            # command used when no other command is given
      :general => %w(version help),  # general commands, can always be run
      :user    => %w(create list),   # commands requiring a credentials (first-time setup)
      :app     => [                  # commands requiring an app to be specified (either by git inference or flag)
        'logs',
        'restart',
        'ps',
        'destroy',
        'console',
        'rake',
        'config',
        'env'
      ],
      :compound => [                 # mult-part commands that expect subsequent arguments, must validate extra args on their own
        'rake',
        'config',
        'env'
      ]
    }
    
    def initialize(args=[], client='duostack')
      @args = args
      @client = client
    end
    
    def run
      @app_name = parse_app # attempt to get app from args. will also try git repo inference later.
      @flags    = parse_flags
      @command  = @args.shift || COMMANDS[:default]
      
      # we consider this run to be confirmed if the app name has been specified in the args and the --confirm flag is passed
      @confirmed = @app_name && @flags.include?('confirm')
      
      # make sure everything is in order
      validate_args                                       # checks for extraneous args and valid command
      require_app if COMMANDS[:app].include?(@command)    # checks that user is set and app can be ID'd
      require_user if COMMANDS[:user].include?(@command)  # checks user credentials
      
      # everything checks out; time to rock and roll
      send(@command)
    end
    
    
    # argument processing methods
    #########################################################################
    
    # app is special because it's a flag with the next arg containing the app name
    # generally we want to pull this first
    def parse_app
      if app_index = @args.index('--app')
        # slice out app args so we don't re-use them later, returning second element.
        # will be nil if no app name is passed after --app; that's okay.
        @args.slice!(app_index, 2)[1]
      end
    end
    
    # extracts and validates any argument starting with '--', indicating a flag
    def parse_flags
      
      # extract flags
      flags = @args.collect do |arg|
        arg[2..-1] if arg[0..1] == '--'
      end.compact
      
      # remove flags from args
      @args.delete_if { |arg| arg[0..1] == '--' }
      
      return flags
    end
    
    # ensures that the command and all extracted flags are what we expect, warns if they aren't
    def validate_args
      
      invalid = []
      invalid += [@command] - COMMANDS.values.flatten   # validate command
      invalid += @flags - FLAGS                          # validate flags
      
      # unless command is compound (expecting further args), any remaining args must be invalid
      invalid += @args unless COMMANDS[:compound].include?(@command)
      
      if invalid.any?
        exit_with("unrecognized argument: '#{invalid.first}', run '#{@client} help' for usage")
      end
    end
    
    
    # validation methods
    #########################################################################
    
    # ensures the app can be identified from inspecting the git repo or command line args
    def require_app
      require_user # all app commands require a user
      @app_name ||= extract_app_name
      unless @app_name
        exit_with "run this command from a Duostack app folder or pass an app name with the --app argument"
      end
      return @app_name
    end
    
    # ensures user credentials are cached
    def require_user
      require_ssh_key # all user commands require an SSH key
      
      @credentials ||= `cat ~/.duostack 2>/dev/null`.chomp
      if @credentials.empty? || @credentials[/redirected/]
        puts "First-time Duostack client setup"
        print "Email Address: "
        input_username = $stdin.gets.chomp
        ssh_key = `cat #{@ssh_key}`.chomp
        puts `bash -c 'read -sp "Password: " passwd; echo $passwd > ~/.duostack2'`
        input_password = CGI::escape(`cat ~/.duostack2`.chomp)
        `rm -f ~/.duostack2`
        `curl -m 5 '#{api_host}/api/get_token?api_username=#{CGI::escape(input_username)}&api_password=#{input_password}&ssh_key=#{CGI::escape(ssh_key)}' -o ~/.duostack -s 2>&1 >/dev/null`
        @credentials = `cat ~/.duostack 2>/dev/null`.chomp
        if @credentials.empty? || @credentials[/redirected/] || @credentials.length != 32
          `rm -f ~/.duostack`
          exit_with "authentication error, please try again or contact support@duostack.com"
        end
        `echo 'api_username=#{CGI::escape(input_username)}&api_token=#{$credentials}' > ~/.duostack`
        @credentials = `cat ~/.duostack 2>/dev/null`.chomp
        puts "Completed initial setup... waiting for sync..."
        sleep 4 # TODO: Do a sync check here in the future, 4 secs is safe for now
        puts ""
      end
      
      return @credentials
    end
    
    def require_ssh_key
      @ssh_key ||= extract_ssh_key
      unless @ssh_key
        exit_with "an SSH key is required to run this command, please generate an SSH key and try again (http://docs.duostack.com/command-line-client#setup)"
      end
      return @ssh_key
    end
    
    
    
    # command methods
    #########################################################################
    
    def version
      puts VERSION
    end
    
    def help
      puts 'i am the help'
    end
    
    
    # utility methods
    #########################################################################
    
    def extract_app_name
      name = `git remote -v 2>&1 | grep -m1 git@duostack.net | grep ".git" | cut -f 2 -d: | cut -f 1 -d.`.chomp
      return name.empty? ? nil : name # ensures nil gets returned instead of an empty string
    end
    
    def extract_ssh_key
      if `file ~/.ssh/id_rsa.pub`[/text|key/]
        '~/.ssh/id_rsa.pub'
      elsif `file ~/.ssh/id_dsa.pub`[/text|key/]
        '~/.ssh/id_dsa.pub'
      elsif `file ~/.ssh/identity.pub`[/text|key/]
        '~/.ssh/identity.pub'
      else
        nil
      end
    end
    
    def api_host
      @api_host ||= begin
        host = "https://duostack.duostack.net"
        if !`curl -V`[/SSL/]
          warn_with "WARNING! curl SSL support is missing, using insecure plaintext mode"
          host = "http://duostack.duostack.net"
        end
        if ENV['DSLOCAL']
          puts "Internal development mode"
          host = "http://localhost:3000"
        end
        host
      end
    end
    
    def debug(message)
      puts message if ENV['DSDEBUG']
    end
    
    def warn_with(message='error')
      warn "#{@client}: #{message}"
    end
    
    def exit_with(message=nil, code=false)
      warn_with message
      exit code
    end
    
  end
end


Duostack::Client.new(ARGV.dup, File.basename(__FILE__)).run



###############################################################################################
###############################################################################################
###############################################################################################
###############################################################################################
###############################################################################################


exit

# parse out confirmedness
$confirmed = app_name_source == :flag && flags.delete('--confirm')
def require_confirmation
  unless $confirmed
    warn "#{$client}: command requires confirmation, run again with '--confirm --app <appname>'"
    exit false
  end
end

# parse out CRUD commands (two-part commands)
command_noun, command_verb, command_argument = [nil]*3
['env'].each do |command_candidate|
  
  # look for any instances of CRUD commands
  if command_index = ARGV.index(command_candidate)
    command_noun = command_candidate
    command_verb = if %w(add remove rm list ls clear).include?(ARGV[command_index+1])
      ARGV[command_index+1]
    else
      'list' # default command
    end
    command_argument = if %w(add remove rm).include?(command_verb)
      # takes all following arguments. recompose strings because ruby strips out quotation marks in the args.
      ARGV[(command_index+2)..-1].collect do |arg|
        if arg.include?('=')
          result = arg.split('=',2)
          %Q(#{result[0]}="#{result[1].gsub('"', '\"')}")
        else
          arg
        end
      end.join(' ')
    end
    ARGV.slice!(command_index..-1) # clear args we've handled out of array
    break
  end
end





def api_get(url)
  debug = `echo curl -m 30 -w '\n%{http_code}' "#{$api_host}/#{url}&#{$credentials}" -sf`
  result = `curl -m 30 -w '\n%{http_code}' "#{$api_host}/#{url}&#{$credentials}" -sf`
  debug += result
  puts debug if ENV['DSDEBUG']
  
  result = result.split("\n")
  if result.last != '200'
    return "API Error"
  else
    return result[0..-2].join("\n")
  end
end

if (!command_noun && ARGV.length == 0) || ARGV[0] == "help"
  puts <<-EOF
Usage: #{$client} <command> [--app <appname>]

General Commands:          
  create <appname>          Initialize a Git repository as a Duostack app
  list                      Show all associated Duostack apps
  version                   Print version of this Duostack client
                           
App Commands:              
  logs                      Retrieve server logs
  restart                   Restart instances
  ps                        List instances with current status
  destroy                   Destroy Duostack app and associated data
                           
  config <name>             Show configuration option choices and selection
  config <name> <val>       Set configuration option to a value
                           
  env list [--long]         List environment variables
  env add <name>=<val>      Add environment variable
  env remove <name>         Remove environment variable
  env clear                 Clear all environment variables
                           
App Commands - Ruby:       
  console                   Connect to IRB/Rails console
  rake <command>            Run a Rake command

EOF
  exit
end

if ARGV[0] == "list"
  result = api_get("api/list_apps?1")
  unless result == 'API Error'
    puts result
    exit
  else
    warn "#{$client}: no apps found"
    exit false
  end
end

if ARGV[0] == "create"
  if ARGV.length < 2
    warn "#{$client}: try '#{$client} create <app name>'"
    exit false
  end
  if `git status 2>&1`[/Not a git/]
    warn "#{$client}: initialize Git repository before using create"
    exit false
  end
  if !app.empty?
    warn "#{$client}: this repository is already initialized for Duostack"
    exit false
  end
  # check if remote duostack already exists in the future
  if api_get("api/create_app?app_name=#{CGI::escape(ARGV[1].downcase)}")[/SUCCESS/]
    `git remote add duostack git@duostack.net:#{CGI::escape(ARGV[1].downcase)}.git`
    puts "Duostack initialized. To push: git push duostack master"
    exit
  else
    puts "This app name is unavailable. Please try another."
    exit false
  end
end





if command_noun == 'env'
  
  case command_verb
  when 'list', 'ls'
    truncate = !flags.delete('--long')
    result = api_get("api/list_envs?app_name=#{app}&truncate=#{truncate}")
    unless result == 'API Error'
      print result
      exit
    else
      puts "Unable to list environment variables"
      exit false
    end
    
  when 'add'
    result = api_get("api/add_env?app_name=#{app}&input=#{CGI::escape(command_argument)}")
    unless result == 'API Error'
      puts result
      exit
    else
      puts "Unable to add environment variable(s)"
      exit false
    end
    
  when 'remove', 'rm'
    result = api_get("api/remove_env?app_name=#{app}&name=#{CGI::escape(command_argument)}")
    if result[/SUCCESS/]
      puts "Environment variable(s) removed"
      exit
    else
      puts "Unable to remove environment variable(s)"
      exit false
    end
    
  when 'clear'
    require_confirmation
    
    result = api_get("api/clear_envs?app_name=#{app}")
    if result[/SUCCESS/]
      puts "Environment variables cleared"
      exit
    else
      puts "Unable to clear environment variables"
      exit false
    end
  else
    exit false # this shouldn't happen
  end
end


if ARGV[0] == "config"
  
  name, value = ARGV[1..2] # value will be nil if there is no ARGV[2]
  
  if name
    if value
      result = api_get("api/option_set?app_name=#{app}&name=#{name}&val=#{value}")
      unless result == 'API Error'
        puts result
        exit
      else
        puts "Unable to set config option"
        exit false
      end
      
    else
      # no value given, get option list
      result = api_get("api/option_get?app_name=#{app}&name=#{name}")
      unless result == 'API Error'
        puts result
        exit
      else
        puts "Unable to get config option"
        exit false
      end
    end
    
  else
    warn "#{$client}: try '#{$client} config <name> <value>'"
    exit false
  end
  
end


if ARGV[0] == "console"
  exec(".duostack-console-expect #{app}")
  exit
end

if ARGV[0] == "rake"
  if ARGV.length < 2
    warn "#{$client}: try '#{$client} rake <command>'"
    exit false
  end
  # Need this to go longer
  result = `curl -m 60 "#{$api_host}/api/run_rake?app_name=#{app}&command=#{CGI::escape(ARGV[1,999].join(' '))}&#{$credentials}" -s`
  if result[/\n/]
    puts result
    exit
  else
    puts "Unable to run rake task"
    exit false
  end
end

if ARGV[0] == "restart"
  get_log = api_get("api/restart?app_name=#{app}")
  if get_log[/SUCCESS/]
    puts "App restarted"
    exit
  else
    puts "Unable to restart app"
    exit false
  end
end

if ARGV[0] == "logs"
  get_log = api_get("api/get_logs?app_name=#{app}")
  if get_log[/\.log/]
    puts get_log
    exit
  else
    warn "#{$client}: no logs found"
    exit false
  end
end

if ARGV[0] == "ps"
  result = api_get("api/get_instances?app_name=#{app}")
  if result[/Instance ID|Status/]
    puts result
    exit
  else
    warn "#{$client}: unable to get instances"
    exit false
  end
end

if ARGV[0] == "destroy"
  
  require_confirmation
  
  remote = `git remote show duostack 2>/dev/null`     # pull out remote name before we destroy
  result = api_get("api/delete_app?app_name=#{app}")  # destroy
  
  if result[/SUCCESS/]
    # attempt to remove duostack git remote
    # only if "duostack" remote actually references this app's remote
    if !remote.empty? and remote.scan("git@duostack.net:#{app}.git").length > 0
      `git remote rm duostack 2>/dev/null`
    end
    
    puts "App destroyed"
    exit
  else
    puts "Unable to destroy app"
    exit false
  end

end

puts "#{$client}: for usage, run '#{$client}' without arguments"
exit false

